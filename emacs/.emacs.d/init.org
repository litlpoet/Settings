#+AUTHOR: Byungkuk Choi
#+email: litlpoet@gmail.com
#+STARTUP: fninline content
#+SEQ_TODO: TODO READY DONE

* init.el
** Preparation
*** load themes
#+BEGIN_SRC emacs-lisp
(setq inhibit-startup-screen t)
(add-hook 'after-init-hook 'toggle-frame-fullscreen)
(use-package atom-one-dark-theme
  :ensure t
  :defer t
  :init (load-theme 'atom-one-dark t))
;; (use-package color-theme-sanityinc-tomorrow
;;   :ensure t
;;   :defer t
;;   :init (load-theme 'sanityinc-tomorrow-night t))
(use-package smart-mode-line
  :ensure t
  :defer t
  :init
  (setq sml/mode-width 'right)
  (setq sml/theme 'dark)
  (setq sml/name-width 35)
  (setq sml/extra-filler 7)
  (add-hook 'after-init-hook
            '(lambda()
               (sml/setup)
               (set-face-attribute 'mode-line nil
                                   :family "Envy Code R"
                                   :box nil
                                   :height 1.0)
               (set-face-attribute 'mode-line-inactive nil
                                   :family "Envy Code R"
                                   :box nil
                                   :height 1.0)
               (set-face-attribute 'fringe nil
                    :inherit 'default-face))))
#+END_SRC

*** set encoding
#+BEGIN_SRC emacs-lisp
(if (eq system-type 'windows-nt)
    (setq locale-coding-system 'korean-cp949)
  (setq locale-coding-system 'utf-8))
;; (set-language-environment 'UTF-8)
(set-language-environment "Korean")
(prefer-coding-system 'utf-8)
(set-terminal-coding-system 'utf-8)
(set-keyboard-coding-system 'utf-8)
(set-selection-coding-system 'utf-8)
#+END_SRC

*** set fonts
#+BEGIN_SRC emacs-lisp
(if (eq system-type 'windows-nt)
    (add-to-list 'default-frame-alist '(font . "Source Code Pro-14"))
  (add-to-list 'default-frame-alist '(font . "DejaVu Sans Mono-14")))
(set-fontset-font t 'hangul (font-spec :name "NanumGothicCoding"))
#+END_SRC

*** set backup
#+BEGIN_SRC emacs-lisp
(defconst bk:backup-directory
  (expand-file-name "tmp" user-emacs-directory)
  "The temporary directory")
(unless (file-exists-p bk:backup-directory)
    (make-directory bk:backup-directory t))
(setq backup-directory-alist `(("." . ,bk:backup-directory))
      backup-by-copying   t
      kept-new-versions   5
      kept-old-versions   3
      auto-save-timeout   120
      delete-old-versions t)
#+END_SRC

*** set cursor
#+BEGIN_SRC emacs-lisp
(blink-cursor-mode 0)
(setq-default cursor-type 'bar)
#+END_SRC


** Built-in Package Setup
*** dired
#+BEGIN_SRC emacs-lisp
(if (eq system-type 'windows-nt)
    (setq dired-listing-switches "-lha")
  (setq dired-listing-switches "-lha --group-directories-first"))
(setq dired-dwim-target       t
      dired-recursive-copies  'always
      dired-recursive-deletes 'always)
;; (add-hook 'dired-mode-hook 'auto-revert-mode)
#+END_SRC

*** prog-mode
#+BEGIN_SRC emacs-lisp
;; (add-hook 'prog-mode-hook 'linum-mode)
(add-to-list 'auto-mode-alist '("\\.h\\'" . c++-mode))
#+END_SRC

*** auto-insert
#+BEGIN_SRC emacs-lisp
(defun bk:format-include-guard-fallback ()
  "Generate an include guard string with file name."
  (let ((filename
         (file-name-nondirectory
          (file-name-sans-extension buffer-file-name)))
        (ext
         (file-name-extension buffer-file-name)))
    (replace-regexp-in-string
     "[^A-Z0-9_]" "_"
     (upcase (concat filename "_" ext "_")))))

(defun bk:format-include-guard ()
  "Format an include guard, using projectile-project-root.
  If not in a projectile project use `bk:format-include-guard-fallback'."
  (if (projectile-project-p)
      (let ((filename
             (subseq
              (file-name-sans-extension buffer-file-name)
              (length (projectile-project-root))))
            (ext (file-name-extension buffer-file-name)))
        (replace-regexp-in-string
         "[^A-Z0-9_]" "_"
         (upcase (concat filename "_" ext "_"))))
    (bk:format-include-guard-fallback)))

(defun bk:generate-include-guard ()
  "Generate an include guard (should be in a C/C++ file),
   used by `auto-insert-mode'."
  (insert "guard")
  (yas/expand))

(defconst bk:auto-insert-dir
  (file-name-as-directory
   (expand-file-name "bk-inserts" user-emacs-directory)))

(defvar bk:auto-insert-alist
  '(;; file pattern . ["filename-to-insert" insertion-function] or
    ;; (file pattern . description) . action (see `auto-insert-alist').
    (("\\.[hH]\\(h\\|pp\\)?$" . "C/C++ header") . bk:generate-include-guard)))

(auto-insert-mode t)
(setq auto-insert-directory bk:auto-insert-dir)
(dolist (elem bk:auto-insert-alist)
  (add-to-list 'auto-insert-alist elem))
(setq auto-insert-query nil)
#+END_SRC

*** auto-revert
#+BEGIN_SRC emacs-lisp
(use-package autorevert
  :defer t
  :diminish auto-revert-mode
  :init
  (setq auto-revert-verbose nil)
  (global-auto-revert-mode t))
#+END_SRC

*** whitespace
#+BEGIN_SRC emacs-lisp
(use-package whitespace
  :defer t
  :diminish whitespace-mode
  :init
  (add-hook 'diff-mode-hook
            '(lambda()
               (setq-local
                whitespace-style '(face
                                   tabs
                                   tab-mark
                                   trailing
                                   indentation::space
                                   indentation::tab
                                   spaces
                                   space-mark
                                   newline
                                   newline-mark))
               (whitespace-mode 1)))
  (add-hook 'prog-mode-hook
            '(lambda()
               (setq-local show-trailing-whitespace 1)
               (setq-local whitespace-style '(face
                                              tabs
                                              trailing
                                              lines-tail))
               (whitespace-mode 1)))
  :config
  (set-face-foreground 'whitespace-line nil))
#+END_SRC

*** abbrev
#+BEGIN_SRC emacs-lisp
(use-package abbrev
  :defer t
  :diminish abbrev-mode)
#+END_SRC

*** flyspell
#+BEGIN_SRC emacs-lisp
(use-package flyspell
  :defer t
  :init
  (setq flyspell-mode-line-string " FlyS")
  (add-hook 'org-mode-hook 'flyspell-mode)
  (add-hook 'TeX-mode-hook 'flyspell-mode))
#+END_SRC


** External Package Setup
*** global core packages
**** (proj) projectile
#+BEGIN_SRC emacs-lisp
(use-package projectile
  :ensure t
  :init
  (setq projectile-indexing-method 'alien)
  (setq projectile-mode-line
        '(:eval (format " Prj[%s]" (projectile-project-name))))
  :config
  (projectile-global-mode)
  (add-to-list 'projectile-other-file-alist '("cc" "h"))
  (add-to-list 'projectile-other-file-alist '("h" "cc")))
#+END_SRC

**** (navi) helm
#+BEGIN_SRC emacs-lisp 
(use-package helm
  :ensure t
  :defer t
  :diminish helm-mode
  :bind (("C-c h"   . helm-command-prefix)
         ("C-x b"   . helm-mini)
         ("C-x C-f" . helm-find-files)
         ("M-x"     . helm-M-x)
         ("M-y"     . helm-show-kill-ring))
  :init
  (require 'helm-config)
  (setq
   helm-split-window-in-side-p           t
   helm-move-to-line-cycle-in-source     t
   helm-ff-search-library-in-sexp        t
   helm-scroll-amount                    1
   helm-ff-file-name-history-use-recentf t
   helm-M-x-fuzzy-match                  t
   helm-buffers-fuzzy-matching           t
   helm-recentf-fuzzy-match              t)
  (when (executable-find "curl")
    (setq helm-google-suggest-use-curl-p t))
  (helm-mode 1)
  (helm-autoresize-mode t)
  :config
  ;; helm-map is enabled maybe after (helm-mode) is activated!
  (unbind-key "C-x c")
  (bind-key "<tab>" 'helm-execute-persistent-action helm-map)
  (bind-key "C-i" 'helm-execute-persistent-action helm-map)
  (bind-key "C-z" 'helm-select-action helm-map))
#+END_SRC

**** (navi) helm-ag
#+BEGIN_SRC emacs-lisp
(eval-after-load 'helm
  '(use-package helm-ag
     :ensure t
     :init
     (setq helm-ag-insert-at-point 'symbol)))
#+END_SRC

**** (navi) helm-projectile
#+BEGIN_SRC emacs-lisp
(eval-after-load 'helm
  '(use-package helm-projectile
     :ensure t
     :init
     (helm-projectile-on)
     ;; helm-projectile-on will change below params if activated later
     (setq projectile-completion-system 'helm)
     (setq projectile-switch-project-action 'projectile-dired)))
#+END_SRC

**** (navi) avy
#+BEGIN_SRC emacs-lisp
(use-package avy
  :ensure t
  :bind ("C-c j" . avy-goto-word-or-subword-1))
#+END_SRC

**** (navi) ace-window
#+BEGIN_SRC emacs-lisp
(use-package ace-window
  :ensure t
  :bind ("C-x o" . ace-window))
#+END_SRC

**** (navi) which-key
#+BEGIN_SRC emacs-lisp
(use-package which-key
  :ensure t
  :defer t
  :diminish which-key-mode
  :init
  (add-hook 'after-init-hook 'which-key-mode))
#+END_SRC

**** (cmpl) company
#+BEGIN_SRC emacs-lisp
(use-package company
  :ensure t
  :defer t
  :diminish company-mode
  :init
  (setq company-selection-wrap-around t)
  (add-hook 'after-init-hook 'global-company-mode)
  :config
  ;; backends loaded after company required
  (setq company-backends (delete 'company-semantic company-backends))
  (setq company-backends (delete 'company-clang company-backends)))
#+END_SRC

**** (cmpl) yasnippet
#+BEGIN_SRC emacs-lisp
(use-package yasnippet
  :ensure t
  :defer t
  :diminish yas-minor-mode
  :init
  (defconst bk:snippet-dir
    (file-name-as-directory
     (expand-file-name "bk-snippets" user-emacs-directory)))
  (if (file-exists-p bk:snippet-dir)
      (setq yas-snippet-dirs (list bk:snippet-dir)))
  :config
  (yas-global-mode 1))
#+END_SRC

**** (file) recentf-ext
#+BEGIN_SRC emacs-lisp
(use-package recentf-ext
  :ensure t
  :defer 2
  :init
  (setq recentf-max-saved-items 200))
#+END_SRC

**** (file) undo-tree
#+BEGIN_SRC emacs-lisp
(use-package undo-tree
  :ensure t
  :diminish undo-tree-mode
  :config
  (global-undo-tree-mode))
#+END_SRC

**** (lint) flycheck
#+BEGIN_SRC emacs-lisp
(use-package flycheck
  :ensure t
  :defer t
  :init
  (add-hook 'after-init-hook #'global-flycheck-mode)
  (add-hook 'org-src-mode-hook
            '(lambda()
               (setq-local flycheck-disabled-checkers
                           '(emacs-lisp-checkdoc)))))
#+END_SRC

*** global helper packages
**** (navi) god-mode
#+BEGIN_SRC emacs-lisp
(use-package god-mode
  :ensure t
  :bind ("<escape>" . god-mode-all)
  :init
  (defun bk:toggle-god-mode-face ()
    (setq cursor-type
          (if (or god-local-mode buffer-read-only)
              'box 'bar))
    (cond (god-local-mode (set-face-background 'highlight "#382a2e"))
          (t (set-face-background 'highlight "#282a2e")))
    (cond (god-local-mode (set-face-background 'mode-line "#150000"))
          (t (set-face-background 'mode-line "black"))))
  (add-hook 'god-mode-enabled-hook 'bk:toggle-god-mode-face)
  (add-hook 'god-mode-disabled-hook 'bk:toggle-god-mode-face)
  :config
  (add-to-list 'god-exempt-major-modes 'helm-mode)
  (add-to-list 'god-exempt-major-modes 'paradox-menu-mode)
  (bind-key "z" 'repeat         god-local-mode-map)
  (bind-key "i" 'god-local-mode god-local-mode-map)
  (use-package god-mode-isearch
    :config
    (bind-key "<escape>" 'god-mode-isearch-activate isearch-mode-map)
    (bind-key "<escape>" 'god-mode-isearch-disable  god-mode-isearch-map)))

#+END_SRC

**** (edit) smartparens
#+BEGIN_SRC emacs-lisp
(use-package smartparens
  :ensure t
  :defer t
  :diminish smartparens-mode
  :init
  (require 'smartparens-config)
  (bind-key "C-M-w" 'sp-copy-sexp smartparens-mode-map)
  (bind-key "M-<delete>" 'sp-unwrap-sexp  smartparens-mode-map)
  (bind-key "M-<backspace>" 'sp-backward-unwrap-sexp smartparens-mode-map)
  (bind-key "M-D" 'sp-splice-sexp smartparens-mode-map)
  (bind-key "M-F" 'sp-forward-symbol smartparens-mode-map)
  (bind-key "M-B" 'sp-backward-symbol smartparens-mode-map)
  (sp-with-modes '(c-mode c++-mode)
    (sp-local-pair "{" nil :post-handlers '(("||\n[i]" "RET"))))
  (sp-local-pair 'c++-mode "/*" "*/"
                 :post-handlers '((" | " "SPC")
                                  ("* ||\n[i]" "RET")))
  (smartparens-global-mode t)
  (show-smartparens-global-mode t)
  :config
  (set-face-attribute 'show-paren-match nil
                      :weight 'extra-bold
                      :underline "yellow"
                      :foreground "gold"
                      :background nil))
#+END_SRC

**** (edit) clean-aindent-mode
#+BEGIN_SRC emacs-lisp
(use-package clean-aindent-mode
  :ensure t
  :defer t
  :init
  (add-hook 'prog-mode-hook 'clean-aindent-mode))
#+END_SRC

**** (edit) iedit
#+BEGIN_SRC emacs-lisp
(use-package iedit
  :ensure t
  :bind ("C-;" . iedit-mode)
  :config
  (set-face-inverse-video 'iedit-occurrence t))
#+END_SRC

**** (edit) expand-region
#+BEGIN_SRC emacs-lisp
(use-package expand-region
  :ensure t
  :bind ("M-2" . er/expand-region))
#+END_SRC

**** (edit) duplicate-thing
#+BEGIN_SRC emacs-lisp
(use-package duplicate-thing
  :ensure t
  :bind ("M-c" . duplicate-thing))
#+END_SRC

**** (edit) multiple-cursors
#+BEGIN_SRC emacs-lisp
(use-package multiple-cursors
  :ensure t
  :bind (("C-." . mc/mark-next-like-this)
         ("C-," . mc/mark-previous-like-this)
         ("C->" . mc/unmark-next-like-this)
         ("C-<" . mc/unmark-previous-like-this)))
#+END_SRC

**** (viz) git-gutter-fringe
#+BEGIN_SRC emacs-lisp
(use-package git-gutter-fringe
  :ensure t
  :diminish git-gutter-mode
  :config
  (global-git-gutter-mode t))
#+END_SRC

**** (viz) volatile-highlights
#+BEGIN_SRC emacs-lisp
(use-package volatile-highlights
  :ensure t
  :diminish volatile-highlights-mode
  :config
  (set-face-background 'vhl/default-face "light slate gray")
  (volatile-highlights-mode t))
#+END_SRC

**** (viz) rainbow-delimiters
#+BEGIN_SRC emacs-lisp
(use-package rainbow-delimiters
  :ensure t
  :defer t
  :init
  (add-hook 'prog-mode-hook #'rainbow-delimiters-mode))
#+END_SRC

*** mode-specific packages
**** (elpa) paradox
#+BEGIN_SRC emacs-lisp
(use-package paradox
  :ensure t
  :defer t
  :init
  (setq paradox-github-token
        (with-temp-buffer
          (insert-file-contents
           (expand-file-name ".github_token" user-emacs-directory))
          (buffer-string)))
  (setq paradox-automatically-star t
        paradox-execute-asynchronously t
        paradox-display-download-count t
        paradox-column-width-package 24
        paradox-column-width-version 12))
#+END_SRC

**** (org) org
#+BEGIN_SRC emacs-lisp
(use-package org
  :ensure t
  :bind (("C-c a" . org-agenda)
         ("C-c c" . org-capture)
         ("C-c l" . org-store-link)
         ("<f12>" . org-clock-goto)
         ("C-<f12>" . org-clock-in))
  :init
  (setq
   org-modules '(org-bbdb
                 org-bibtex
                 org-crypt
                 org-docview
                 org-gnus
                 org-habit
                 org-id
                 org-info
                 org-inlinetask
                 org-irc
                 org-mhe
                 org-protocol
                 org-rmail
                 org-w3m))
  (setq
   org-src-fontify-natively t
   org-src-window-setup 'current-window
   org-src-strip-leading-and-trailing-blank-lines t
   org-src-preserve-indentation t
   org-src-tab-acts-natively t)
  (setq
   org-use-fast-todo-selection t
   org-treat-S-cursor-todo-selection-as-state-change nil
   org-todo-keywords
   '((sequence "TODO(t)" "NEXT(n)" "|" "DONE(d)")
     (sequence "WAITING(w@/!)" "HOLD(h@/!)" "|" "CANCELED(c@/!)" "PHONE" "MEETING"))
   org-todo-state-tags-triggers
   '(("CANCELLED" ("CANCELLED" . t))
     ("WAITING" ("WAITING" . t))
     ("HOLD" ("WAITING") ("HOLD" . t))
     (done ("WAITING") ("HOLD"))
     ("TODO" ("WAITING") ("CANCELLED") ("HOLD"))
     ("NEXT" ("WAITING") ("CANCELLED") ("HOLD"))
     ("DONE" ("WAITING") ("CANCELLED") ("HOLD"))))
  (setq
   org-capture-templates
   '(("t" "todo" entry
      (file "~/Clouds/Dropbox/Org/refile.org")
      "* TODO %?\n%U\n%a\n"
      :clock-in t :clock-resume t)
     ("r" "respond" entry
      (file "~/Clouds/Dropbox/Org/refile.org")
      "* NEXT Respond to %:from on %:subject\nSCHEDULED: %t\n%U\n%a\n"
      :clock-in t :clock-resume t :immediate-finish t)
     ("n" "note" entry
      (file "~/Clouds/Dropbox/Org/refile.org")
      "* %? :NOTE:\n%U\n%a\n"
      :clock-in t :clock-resume t)
     ("j" "Journal" entry
      (file+datetree "~/Clouds/Dropbox/Org/diary.org")
      "* %?\n%U\n"
      :clock-in t :clock-resume t)
     ("w" "org-protocol" entry
      (file "~/Clouds/Dropbox/Org/refile.org")
      "* TODO Review %c\n%U\n"
      :immediate-finish t)
     ("m" "Meeting" entry
      (file "~/Clouds/Dropbox/Org/refile.org")
      "* MEETING with %? :MEETING:\n%U"
      :clock-in t :clock-resume t)
     ("p" "Phone call" entry
      (file "~/Clouds/Dropbox/Org/refile.org")
      "* PHONE %? :PHONE:\n%U"
      :clock-in t :clock-resume t)
     ("h" "Habit" entry
      (file "~/Clouds/Dropbox/Org/refile.org")
      "* NEXT %?\n%U\n%a\nSCHEDULED: %(format-time-string \"%<<%Y-%m-%d %a .+1d/3d>>\")\n:PROPERTIES:\n:STYLE: habit\n:REPEAT_TO_STATE: NEXT\n:END:\n")))
  (setq
   org-refile-targets '((nil :maxlevel . 9)
                        (org-agenda-files :maxlevel . 9))
   org-refile-use-outline-path t
   org-refile-allow-creating-parent-nodes 'confirm
   org-outline-path-complete-in-steps nil)
  (setq
   org-agenda-files '("~/Clouds/Dropbox/Org")
   org-agenda-dim-blocked-tasks nil
   org-agenda-compact-blocks t
   org-agenda-custom-commands
   '(("N" "Notes" tags "NOTE"
      ((org-agenda-overriding-header "Notes")
       (org-tags-match-list-sublevels t)))
     ("h" "Habits" tags-todo "STYLE=\"habit\""
      ((org-agenda-overriding-header "Habits")
       (org-agenda-sorting-strategy
        '(todo-state-down effort-up category-keep))))
     (" " "Agenda"
      ((agenda "" nil)
       (tags
        "REFILE"
        ((org-agenda-overriding-header "Tasks to Refile")
         (org-tags-match-list-sublevels nil)))
       (tags-todo
        "-CANCELLED/!"
        ((org-agenda-overriding-header "Stuck Projects")
         (org-agenda-skip-function 'bh/skip-non-stuck-projects)
         (org-agenda-sorting-strategy '(category-keep))))
       (tags-todo
        "-HOLD-CANCELLED/!"
        ((org-agenda-overriding-header "Projects")
         (org-agenda-skip-function 'bh/skip-non-projects)
         (org-tags-match-list-sublevels 'indented)
         (org-agenda-sorting-strategy '(category-keep))))
       (tags-todo
        "-CANCELLED/!NEXT"
        ((org-agenda-overriding-header
          (concat "Project Next Tasks"
                  (if bh/hide-scheduled-and-waiting-next-tasks
                      ""
                    " (including WAITING and SCHEDULED tasks)")))
         (org-agenda-skip-function
          'bh/skip-projects-and-habits-and-single-tasks)
         (org-tags-match-list-sublevels t)
         (org-agenda-todo-ignore-scheduled
          bh/hide-scheduled-and-waiting-next-tasks)
         (org-agenda-todo-ignore-deadlines
          bh/hide-scheduled-and-waiting-next-tasks)
         (org-agenda-todo-ignore-with-date
          bh/hide-scheduled-and-waiting-next-tasks)
         (org-agenda-sorting-strategy
          '(todo-state-down effort-up category-keep))))
       (tags-todo
        "-REFILE-CANCELLED-WAITING-HOLD/!"
        ((org-agenda-overriding-header
          (concat "Project Subtasks"
                  (if bh/hide-scheduled-and-waiting-next-tasks
                      ""
                    " (including WAITING and SCHEDULED tasks)")))
         (org-agenda-skip-function 'bh/skip-non-project-tasks)
         (org-agenda-todo-ignore-scheduled
          bh/hide-scheduled-and-waiting-next-tasks)
         (org-agenda-todo-ignore-deadlines
          bh/hide-scheduled-and-waiting-next-tasks)
         (org-agenda-todo-ignore-with-date
          bh/hide-scheduled-and-waiting-next-tasks)
         (org-agenda-sorting-strategy
          '(category-keep))))
       (tags-todo
        "-REFILE-CANCELLED-WAITING-HOLD/!"
        ((org-agenda-overriding-header
          (concat "Standalone Tasks"
                  (if bh/hide-scheduled-and-waiting-next-tasks
                      ""
                    " (including WAITING and SCHEDULED tasks)")))
         (org-agenda-skip-function
          'bh/skip-project-tasks)
         (org-agenda-todo-ignore-scheduled
          bh/hide-scheduled-and-waiting-next-tasks)
         (org-agenda-todo-ignore-deadlines
          bh/hide-scheduled-and-waiting-next-tasks)
         (org-agenda-todo-ignore-with-date
          bh/hide-scheduled-and-waiting-next-tasks)
         (org-agenda-sorting-strategy
          '(category-keep))))
       (tags-todo
        "-CANCELLED+WAITING|HOLD/!"
        ((org-agenda-overriding-header
          (concat "Waiting and Postponed Tasks"
                  (if bh/hide-scheduled-and-waiting-next-tasks
                      ""
                    " (including WAITING and SCHEDULED tasks)")))
         (org-agenda-skip-function 'bh/skip-non-tasks)
         (org-tags-match-list-sublevels nil)
         (org-agenda-todo-ignore-scheduled
          bh/hide-scheduled-and-waiting-next-tasks)
         (org-agenda-todo-ignore-deadlines
          bh/hide-scheduled-and-waiting-next-tasks)))
       (tags
        "-REFILE/"
        ((org-agenda-overriding-header "Tasks to Archive")
         (org-agenda-skip-function 'bh/skip-non-archivable-tasks)
         (org-tags-match-list-sublevels nil))))
      nil)))
  ;; Resume clocking task when emacs is restarted
  (org-clock-persistence-insinuate)
  ;; Show lot of clocking history so it's easy to pick items off the C-F11 list
  (setq
   org-clock-history-length 23
   ;; Resume clocking task on clock-in if the clock is open
   org-clock-in-resume t
   ;; Change tasks to NEXT when clocking in
   org-clock-in-switch-to-state 'bh/clock-in-to-next
   ;; Separate drawers for clocking and logs
   org-drawers (quote ("PROPERTIES" "LOGBOOK"))
   ;; Save clock data and state changes and notes in the LOGBOOK drawer
   org-clock-into-drawer t
   ;; Sometimes I change tasks I'm clocking quickly - this removes clocked tasks with 0:00 duration
   org-clock-out-remove-zero-time-clocks t
   ;; Clock out when moving task to a done state
   org-clock-out-when-done t
   ;; Save the running clock and all clock history when exiting Emacs, load it on startup
   org-clock-persist t
   ;; Do not prompt to resume an active clock
   org-clock-persist-query-resume nil
   ;; Enable auto clock resolution for finding open clocks
   org-clock-auto-clock-resolution (quote when-no-clock-is-running)
   ;; Include current clocking task in clock reports
   org-clock-report-include-clocking-task t)

  (setq bh/keep-clock-running nil)

  (add-hook 'org-clock-out-hook 'bh/clock-out-maybe 'append))
#+END_SRC

**** (tex) company-auctex
#+BEGIN_SRC emacs-lisp
(eval-after-load 'company
  '(use-package company-auctex
     :ensure t
     :init
     (company-auctex-init)))
#+END_SRC

**** (c++) irony
#+BEGIN_SRC emacs-lisp
(use-package irony
  :ensure t
  :defer t
  :init
  (defun bk:irony-mode-hook()
    (define-key irony-mode-map [remap completion-at-point]
      'irony-completion-at-point-async)
    (define-key irony-mode-map [remap complete-symbol]
      'irony-completion-at-point-async))
  (add-hook 'irony-mode-hook 'bk:irony-mode-hook)
  (add-hook 'irony-mode-hook 'irony-cdb-autosetup-compile-options)
  (add-hook 'c++-mode-hook 'irony-mode)
  (add-hook 'c-mode-hook
            '(lambda()
               (unless (derived-mode-p 'glsl-mode) (irony-mode))))
  (when (eq system-type 'windows-nt)
    (setq w32-pipe-read-delay 0)))
#+END_SRC

**** (c++) rtags
#+BEGIN_SRC emacs-lisp
(use-package rtags
  :ensure t
  :defer t
  :init
  (setq
   rtags-completions-enabled t
   rtags-jump-to-first-match nil
   rtags-other-window-window-size-percentage 50
   rtags-use-filename-completion nil)
  (rtags-enable-standard-keybindings c-mode-base-map)
  :config
  (set-face-attribute 'rtags-errline nil
                      :underline '(:color "red" :style wave)
                      :background nil)
  (set-face-attribute 'rtags-fixitline nil
                      :underline '(:color "orange" :style wave)
                      :background nil)
  (set-face-attribute 'rtags-skippedline nil
                      :foreground "gray3"
                      :background nil)
  )
#+END_SRC

**** (c++) company-rtags
#+BEGIN_SRC emacs-lisp
(eval-after-load 'company
  '(use-package company-rtags
     :commands company-rtags
     :init
     (add-to-list 'company-backends 'company-rtags)))
#+END_SRC

**** (c++) company-irony
     use company-irony only with key input
     (looks unstable sometimes with idle completion)
#+BEGIN_SRC emacs-lisp
(eval-after-load 'company
  '(use-package company-irony
     :ensure t
     :commands company-irony
     :init
     (bind-key "M-<RET>" 'company-irony c-mode-map)
     (bind-key "M-<RET>" 'company-irony c++-mode-map)))
#+END_SRC

**** (c++) flycheck-irony
#+BEGIN_SRC emacs-lisp
(eval-after-load 'flycheck
  '(use-package flycheck-irony
     :ensure t
     :init
     (add-to-list 'flycheck-checkers 'irony)))
#+END_SRC

**** (c++) flycheck-google-cpplint
#+BEGIN_SRC emacs-lisp
(eval-after-load 'flycheck-irony
  '(use-package flycheck-google-cpplint
     :ensure t
     :config
     (message "flycheck-google-cpplint loaded")
     ;; c/c++-googlelint checker enabled
     ;; after loading the package
     (flycheck-add-next-checker 
      'irony '(warning . c/c++-googlelint))))
#+END_SRC
**** (c++) google-c-style
#+BEGIN_SRC emacs-lisp
(use-package google-c-style
  :ensure t
  :commands (google-set-c-style google-make-newline-indent)
  :init
  (add-hook 'c-mode-common-hook 'google-set-c-style)
  (add-hook 'c-mode-common-hook 'google-make-newline-indent))
#+END_SRC

**** (c++) clang-format
#+BEGIN_SRC emacs-lisp
(use-package clang-format
  :ensure t
  :init
  (bind-key "C-c C-f" 'clang-format-buffer c-mode-base-map)
  (defun bk:clang-format-before-save()
    (interactive)
    (when (or (eq major-mode 'c-mode)
              (eq major-mode 'c++-mode)
              (eq major-mode 'glsl-mode))
      (clang-format-buffer)))
  (add-hook 'before-save-hook 'bk:clang-format-before-save)
  :config
  (setq-default clang-format-style "Google"))
#+END_SRC

**** (c++) cmake-mode and cmake-font-lock
#+BEGIN_SRC emacs-lisp
(autoload 'cmake-font-lock-activate "cmake-font-lock" nil t)
(add-hook 'cmake-mode-hook 'cmake-font-lock-activate)
#+END_SRC

**** (c++) malinka
#+BEGIN_SRC emacs-lisp
(use-package malinka
  :ensure t
  :defer t
  :init
  (add-hook 'c-mode-common-hook 'malinka-mode)
  :config
  (malinka-define-project
   :name "sketchimo"
   :root-directory "/home/bk/VersionControl/Research/sketchimo"
   :build-directory "/home/bk/VersionControl/Research/sketchimo/build"
   :configure-cmd "cmake .."
   :compile-cmd "make -j 8"
   :run-cmd "./build/sketchimo")
  (malinka-define-project
   :name "interpolation"
   :root-directory "/home/bk/VersionControl/Research/interpolation"
   :build-directory "/home/bk/VersionControl/Research/interpolation/build"
   :configure-cmd "cmake .."
   :compile-cmd "make -j 8"
   :run-cmd "./build/interpolation")
  (malinka-define-project
   :name "mocap"
   :root-directory "/home/bk/VersionControl/Research/mocap"
   :build-directory "/home/bk/VersionControl/Research/mocap/build"
   :configure-cmd "cmake .."
   :compile-cmd "make -j 8"
   :run-cmd "./build/mocap")
  (malinka-define-project
   :name "beliefbox"
   :root-directory "/home/bk/VersionControl/Libraries/beliefbox"
   :build-directory "/home/bk/VersionControl/Libraries/beliefbox"
   :compile-cmd "make clean && bear make -j 8"))
#+END_SRC

**** (git) magit
#+BEGIN_SRC emacs-lisp
(use-package magit
  :ensure t
  :config
  (set-face-attribute 'magit-diff-file-heading nil
                      :inverse-video t
                      :weight 'extra-bold))
#+END_SRC

**** (latex) auctex
#+BEGIN_SRC emacs-lisp
(add-hook 'TeX-mode-hook 'linum-mode)
(setq TeX-auto-save t)
(setq TeX-parse-self t)
(setq-default TeX-master nil)
(setq TeX-PDF-mode t)
(setq TeX-source-correlate-mode t)
(when (eq system-type 'windows-nt)
  (setq
   TeX-view-program-list
   '(("Sumatra PDF"
      ("\"C:/Program Files (x86)/SumatraPDF/SumatraPDF.exe\" -reuse-instance"
       (mode-io-correlate " -forward-search %b %n ")
       " %o"))))
  (eval-after-load 'tex
    '(progn
       (assq-delete-all 'output-pdf TeX-view-program-selection)
       (add-to-list 'TeX-view-program-selection
                    '(output-pdf "Sumatra PDF")))))
#+END_SRC

**** (elisp) macrostep
#+BEGIN_SRC emacs-lisp
(use-package macrostep
  :ensure t
  :bind ("C-c e m" . macrostep-expand))
#+END_SRC



** Implementations
*** buffer specific display window
#+BEGIN_SRC emacs-lisp
(require 'rx)
(setq
 display-buffer-alist
 `(;; Put REPLs and error lists into the bottom side window
   (,(rx bos (or "*Flycheck errors*" ; Flycheck error list
                 "*compilation"      ; Compilation buffers
                 "*Warnings*"        ; Emacs warnings
                 "*shell"            ; Shell window
                 "*RTags"            ; RTags
                 ))
    (display-buffer-reuse-window
     display-buffer-in-side-window)
    (side            . bottom)
    (reusable-frames . visible)
    (window-height   . 0.25))
   ("." nil (reusable-frames . visible))))
(defun bk:quit-bottom-side-windows ()
  "Quit windows at the bottom of the current frame."
  (interactive)
  (dolist (window (window-at-side-list nil 'bottom))
    (quit-window nil window)))
(bind-key "C-c q" 'bk:quit-bottom-side-windows)
#+END_SRC

*** window dedication
    setup a decicated window configuration
#+BEGIN_SRC emacs-lisp
(defun bk:toggle-current-window-dedication ()
  "Window dedication."
  (interactive)
  (let* ((window (selected-window))
         (dedicated (window-dedicated-p window)))
    (set-window-dedicated-p window (not dedicated))
    (message "Window %s dedicated to %s"
             (if dedicated "no longer " "")
             (buffer-name))))
(bind-key [pause] 'bk:toggle-current-window-dedication)
#+END_SRC

*** useful window title info.
#+BEGIN_SRC emacs-lisp
(setq
 frame-title-format
 '("" invocation-name ": "
   (:eval
    (if (buffer-file-name)
        (abbreviate-file-name (buffer-file-name))
      "%b"))))
#+END_SRC

*** bh org related functions
#+BEGIN_SRC emacs-lisp
(defvar bh/hide-scheduled-and-waiting-next-tasks t)

(defvar bh/organization-task-id "d705cc21-b5b2-4dec-81ed-83e4f2ff3e6c")

(defun bh/hide-other ()
  (interactive)
  (save-excursion
    (org-back-to-heading 'invisible-ok)
    (hide-other)
    (org-cycle)
    (org-cycle)
    (org-cycle)))

(defun bh/set-truncate-lines ()
  "Toggle value of truncate-lines and refresh window display."
  (interactive)
  (setq truncate-lines (not truncate-lines))
  ;; now refresh window display (an idiom from simple.el):
  (save-excursion
    (set-window-start (selected-window)
                      (window-start (selected-window)))))

(defun bh/find-project-task ()
  "Move point to the parent (project) task if any"
  (save-restriction
    (widen)
    (let ((parent-task (save-excursion (org-back-to-heading 'invisible-ok) (point))))
      (while (org-up-heading-safe)
        (when (member (nth 2 (org-heading-components)) org-todo-keywords-1)
          (setq parent-task (point))))
      (goto-char parent-task)
      parent-task)))

(defun bh/is-project-p ()
  "Any task with a todo keyword subtask"
  (save-restriction
    (widen)
    (let ((has-subtask)
          (subtree-end (save-excursion (org-end-of-subtree t)))
          (is-a-task (member (nth 2 (org-heading-components)) org-todo-keywords-1)))
      (save-excursion
        (forward-line 1)
        (while (and (not has-subtask)
                    (< (point) subtree-end)
                    (re-search-forward "^\*+ " subtree-end t))
          (when (member (org-get-todo-state) org-todo-keywords-1)
            (setq has-subtask t))))
      (and is-a-task has-subtask))))

(defun bh/is-project-subtree-p ()
  "Any task with a todo keyword that is in a project subtree.
Callers of this function already widen the buffer view."
  (let ((task (save-excursion (org-back-to-heading 'invisible-ok)
                              (point))))
    (save-excursion
      (bh/find-project-task)
      (if (equal (point) task)
          nil
        t))))

(defun bh/is-task-p ()
  "Any task with a todo keyword and no subtask"
  (save-restriction
    (widen)
    (let ((has-subtask)
          (subtree-end (save-excursion (org-end-of-subtree t)))
          (is-a-task (member (nth 2 (org-heading-components)) org-todo-keywords-1)))
      (save-excursion
        (forward-line 1)
        (while (and (not has-subtask)
                    (< (point) subtree-end)
                    (re-search-forward "^\*+ " subtree-end t))
          (when (member (org-get-todo-state) org-todo-keywords-1)
            (setq has-subtask t))))
      (and is-a-task (not has-subtask)))))

(defun bh/is-subproject-p ()
  "Any task which is a subtask of another project"
  (let ((is-subproject)
        (is-a-task (member (nth 2 (org-heading-components)) org-todo-keywords-1)))
    (save-excursion
      (while (and (not is-subproject) (org-up-heading-safe))
        (when (member (nth 2 (org-heading-components)) org-todo-keywords-1)
          (setq is-subproject t))))
    (and is-a-task is-subproject)))

(defun bh/list-sublevels-for-projects-indented ()
  "Set org-tags-match-list-sublevels so when restricted to a subtree we list all subtasks.
  This is normally used by skipping functions where this variable is already local to the agenda."
  (if (marker-buffer org-agenda-restrict-begin)
      (setq org-tags-match-list-sublevels 'indented)
    (setq org-tags-match-list-sublevels nil))
  nil)

(defun bh/list-sublevels-for-projects ()
  "Set org-tags-match-list-sublevels so when restricted to a subtree we list all subtasks.
  This is normally used by skipping functions where this variable is already local to the agenda."
  (if (marker-buffer org-agenda-restrict-begin)
      (setq org-tags-match-list-sublevels t)
    (setq org-tags-match-list-sublevels nil))
  nil)

(defun bh/toggle-next-task-display ()
  (interactive)
  (setq bh/hide-scheduled-and-waiting-next-tasks (not bh/hide-scheduled-and-waiting-next-tasks))
  (when  (equal major-mode 'org-agenda-mode)
    (org-agenda-redo))
  (message "%s WAITING and SCHEDULED NEXT Tasks" (if bh/hide-scheduled-and-waiting-next-tasks "Hide" "Show")))

(defun bh/skip-stuck-projects ()
  "Skip trees that are not stuck projects"
  (save-restriction
    (widen)
    (let ((next-headline (save-excursion (or (outline-next-heading) (point-max)))))
      (if (bh/is-project-p)
          (let* ((subtree-end (save-excursion (org-end-of-subtree t)))
                 (has-next ))
            (save-excursion
              (forward-line 1)
              (while (and (not has-next) (< (point) subtree-end) (re-search-forward "^\\*+ NEXT " subtree-end t))
                (unless (member "WAITING" (org-get-tags-at))
                  (setq has-next t))))
            (if has-next
                nil
              next-headline)) ; a stuck project, has subtasks but no next task
        nil))))

(defun bh/skip-non-stuck-projects ()
  "Skip trees that are not stuck projects"
  ;; (bh/list-sublevels-for-projects-indented)
  (save-restriction
    (widen)
    (let ((next-headline (save-excursion (or (outline-next-heading) (point-max)))))
      (if (bh/is-project-p)
          (let* ((subtree-end (save-excursion (org-end-of-subtree t)))
                 (has-next ))
            (save-excursion
              (forward-line 1)
              (while (and (not has-next) (< (point) subtree-end) (re-search-forward "^\\*+ NEXT " subtree-end t))
                (unless (member "WAITING" (org-get-tags-at))
                  (setq has-next t))))
            (if has-next
                next-headline
              nil)) ; a stuck project, has subtasks but no next task
        next-headline))))

(defun bh/skip-non-projects ()
  "Skip trees that are not projects"
  ;; (bh/list-sublevels-for-projects-indented)
  (if (save-excursion (bh/skip-non-stuck-projects))
      (save-restriction
        (widen)
        (let ((subtree-end (save-excursion (org-end-of-subtree t))))
          (cond
           ((bh/is-project-p)
            nil)
           ((and (bh/is-project-subtree-p) (not (bh/is-task-p)))
            nil)
           (t
            subtree-end))))
    (save-excursion (org-end-of-subtree t))))

(defun bh/skip-non-tasks ()
  "Show non-project tasks.
Skip project and sub-project tasks, habits, and project related tasks."
  (save-restriction
    (widen)
    (let ((next-headline (save-excursion (or (outline-next-heading) (point-max)))))
      (cond
       ((bh/is-task-p)
        nil)
       (t
        next-headline)))))

(defun bh/skip-project-trees-and-habits ()
  "Skip trees that are projects"
  (save-restriction
    (widen)
    (let ((subtree-end (save-excursion (org-end-of-subtree t))))
      (cond
       ((bh/is-project-p)
        subtree-end)
       ((org-is-habit-p)
        subtree-end)
       (t
        nil)))))

(defun bh/skip-projects-and-habits-and-single-tasks ()
  "Skip trees that are projects, tasks that are habits, single non-project tasks"
  (save-restriction
    (widen)
    (let ((next-headline (save-excursion (or (outline-next-heading) (point-max)))))
      (cond
       ((org-is-habit-p)
        next-headline)
       ((and bh/hide-scheduled-and-waiting-next-tasks
             (member "WAITING" (org-get-tags-at)))
        next-headline)
       ((bh/is-project-p)
        next-headline)
       ((and (bh/is-task-p) (not (bh/is-project-subtree-p)))
        next-headline)
       (t
        nil)))))

(defun bh/skip-project-tasks-maybe ()
  "Show tasks related to the current restriction.
When restricted to a project, skip project and sub project tasks, habits, NEXT tasks, and loose tasks.
When not restricted, skip project and sub-project tasks, habits, and project related tasks."
  (save-restriction
    (widen)
    (let* ((subtree-end (save-excursion (org-end-of-subtree t)))
           (next-headline (save-excursion (or (outline-next-heading) (point-max))))
           (limit-to-project (marker-buffer org-agenda-restrict-begin)))
      (cond
       ((bh/is-project-p)
        next-headline)
       ((org-is-habit-p)
        subtree-end)
       ((and (not limit-to-project)
             (bh/is-project-subtree-p))
        subtree-end)
       ((and limit-to-project
             (bh/is-project-subtree-p)
             (member (org-get-todo-state) (list "NEXT")))
        subtree-end)
       (t
        nil)))))

(defun bh/skip-project-tasks ()
  "Show non-project tasks.
Skip project and sub-project tasks, habits, and project related tasks."
  (save-restriction
    (widen)
    (let* ((subtree-end (save-excursion (org-end-of-subtree t))))
      (cond
       ((bh/is-project-p)
        subtree-end)
       ((org-is-habit-p)
        subtree-end)
       ((bh/is-project-subtree-p)
        subtree-end)
       (t
        nil)))))

(defun bh/skip-non-project-tasks ()
  "Show project tasks.
Skip project and sub-project tasks, habits, and loose non-project tasks."
  (save-restriction
    (widen)
    (let* ((subtree-end (save-excursion (org-end-of-subtree t)))
           (next-headline (save-excursion (or (outline-next-heading) (point-max)))))
      (cond
       ((bh/is-project-p)
        next-headline)
       ((org-is-habit-p)
        subtree-end)
       ((and (bh/is-project-subtree-p)
             (member (org-get-todo-state) (list "NEXT")))
        subtree-end)
       ((not (bh/is-project-subtree-p))
        subtree-end)
       (t
        nil)))))

(defun bh/skip-projects-and-habits ()
  "Skip trees that are projects and tasks that are habits"
  (save-restriction
    (widen)
    (let ((subtree-end (save-excursion (org-end-of-subtree t))))
      (cond
       ((bh/is-project-p)
        subtree-end)
       ((org-is-habit-p)
        subtree-end)
       (t
        nil)))))

(defun bh/skip-non-subprojects ()
  "Skip trees that are not projects"
  (let ((next-headline (save-excursion (outline-next-heading))))
    (if (bh/is-subproject-p)
        nil
      next-headline)))

(defun bh/clock-in-to-next (kw)
  "Switch a task from TODO to NEXT when clocking in.
Skips capture tasks, projects, and subprojects.
Switch projects and subprojects from NEXT back to TODO"
  (when (not (and (boundp 'org-capture-mode) org-capture-mode))
    (cond
     ((and (member (org-get-todo-state) (list "TODO"))
           (bh/is-task-p))
      "NEXT")
     ((and (member (org-get-todo-state) (list "NEXT"))
           (bh/is-project-p))
      "TODO"))))

(defun bh/punch-in (arg)
  "Start continuous clocking and set the default task to the
selected task.  If no task is selected set the Organization task
as the default task."
  (interactive "p")
  (setq bh/keep-clock-running t)
  (if (equal major-mode 'org-agenda-mode)
      ;;
      ;; We're in the agenda
      ;;
      (let* ((marker (org-get-at-bol 'org-hd-marker))
             (tags (org-with-point-at marker (org-get-tags-at))))
        (if (and (eq arg 4) tags)
            (org-agenda-clock-in '(16))
          (bh/clock-in-organization-task-as-default)))
    ;;
    ;; We are not in the agenda
    ;;
    (save-restriction
      (widen)
                                        ; Find the tags on the current task
      (if (and (equal major-mode 'org-mode) (not (org-before-first-heading-p)) (eq arg 4))
          (org-clock-in '(16))
        (bh/clock-in-organization-task-as-default)))))

(defun bh/punch-out ()
  (interactive)
  (setq bh/keep-clock-running nil)
  (when (org-clock-is-active)
    (org-clock-out))
  (org-agenda-remove-restriction-lock))

(defun bh/clock-in-default-task ()
  (save-excursion
    (org-with-point-at org-clock-default-task
      (org-clock-in))))

(defun bh/clock-in-parent-task ()
  "Move point to the parent (project) task if any and clock in"
  (let ((parent-task))
    (save-excursion
      (save-restriction
        (widen)
        (while (and (not parent-task) (org-up-heading-safe))
          (when (member (nth 2 (org-heading-components)) org-todo-keywords-1)
            (setq parent-task (point))))
        (if parent-task
            (org-with-point-at parent-task
              (org-clock-in))
          (when bh/keep-clock-running
            (bh/clock-in-default-task)))))))

(defun bh/clock-in-organization-task-as-default ()
  (interactive)
  (org-with-point-at (org-id-find bh/organization-task-id 'marker)
    (org-clock-in '(16))))

(defun bh/clock-out-maybe ()
  (when (and bh/keep-clock-running
             (not org-clock-clocking-in)
             (marker-buffer org-clock-default-task)
             (not org-clock-resolving-clocks-due-to-idleness))
    (bh/clock-in-parent-task)))
#+END_SRC


** Key Bindings
*** global keys
#+BEGIN_SRC emacs-lisp
(bind-key "M-9"    'backward-sexp)
(bind-key "M-0"    'forward-sexp)
(bind-key "M-1"    'delete-other-windows)
(bind-key "C-x k"  'kill-this-buffer)
(bind-key "RET"    'newline-and-indent)
(bind-key "<kana>" 'toggle-input-method)
#+END_SRC
*** alias
#+BEGIN_SRC emacs-lisp
(defalias 'yes-or-no-p 'y-or-n-p)
#+END_SRC


** Platform Dependent Setup
*** windows
#+BEGIN_SRC emacs-lisp
(when (eq system-type 'windows-nt)
  (setenv "GIT_ASKPASS" "git-gui--askpass"))
#+END_SRC


* Disabled configuration
** Preparation
*** control package archives
#+BEGIN_SRC emacs-lisp
(require 'package)
(add-to-list 'package-archives
             '("melpa" . "http://melpa.org/packages/") t)
(add-to-list 'package-archives
             '("org" . "http://orgmode.org/elpa/") t)
(package-initialize)
#+END_SRC

*** load custom file location
    Make customize setting separated from the init{.el, .org} files
    note: try to use customize for built-in packages
#+BEGIN_SRC emacs-lisp
(setq custom-file (expand-file-name "custom.el" user-emacs-directory))
(load custom-file)
#+END_SRC

*** load use-package
#+BEGIN_SRC emacs-lisp
;; Set-up use-package
;; use-package is used to configure the rest of the packages.
(unless (package-installed-p 'use-package)
  (package-refresh-contents)
  (package-install 'use-package))
(eval-when-compile (require 'use-package))
(require 'diminish)
(require 'bind-key)
(setq use-package-verbose t)
#+END_SRC

*** check package installation

    1) Check if all packages are installed.
    2) If some packages are missing, install them automatically

#+BEGIN_SRC emacs-lisp 
(require 'cl)
(defun bk:packages-installed()
  (loop for p in package-selected-packages
        when (not (package-installed-p p))
        do (return nil)
        finally (return t)))

(unless (bk:packages-installed) ; check for new packages (package versions)
  (message "%s" "Emacs is now refreshing its package database...")
  (package-refresh-contents)
  (message "%s" "done.")
  (dolist (p package-selected-packages) ; install the missing packages
    (when (not (package-installed-p p))
      (package-install p))))
#+END_SRC


** Built-in Package Setup


** External Package Setup
*** global helper packages
*** mode-specific packages
**** company-irony
#+BEGIN_SRC emacs-lisp
(eval-after-load 'company
  '(progn
     (require 'company-irony)
     ;; (require 'company-irony-c-headers) ;; not mature yet
     (add-to-list 'company-backends 'company-irony)
     (add-hook 'irony-mode-hook 'company-irony-setup-begin-commands)))
#+END_SRC

**** company-c-headers
     this back-end should go before company-irony (using 'add-to-list')
#+BEGIN_SRC emacs-lisp
(eval-after-load 'company
  '(progn
     (require 'company-c-headers)
     (add-to-list 'company-backends 'company-c-headers)
     (when (eq system-type 'windows-nt)
       (setq
        company-c-headers-path-system
        '("c:/Local/msys64/mingw64/x86_64-w64-mingw32/include/"
          "c:/Local/msys64/mingw64/include/"
          "c:/Local/msys64/mingw64/include/c++/5.2.0/"
          "c:/Local/include/eigen3/")))
     (when (eq system-type 'gnu/linux)
       (setq
        company-c-headers-path-system
        (append
         company-c-headers-path-system
         '("/usr/include/c++/4.9/"
           "/usr/local/include/eigen3/"
           "/opt/qt5/5.5/gcc_64/include/"
           "/home/bk/VersionControl/Modules/libML"))))
     (setq company-c-headers-path-user '("." ".."))))
#+END_SRC

**** (c++) cmake-ide
#+BEGIN_SRC emacs-lisp
(eval-after-load 'rtags
  '(use-package cmake-ide
     :ensure t
     :defer t
     :init (cmake-ide-setup)))
#+END_SRC


** Implementations
*** hidden mode-line
#+BEGIN_SRC emacs-lisp
(defvar-local toggle-mode-line nil)
(defvar-local hide-mode-line nil)
(define-minor-mode toggle-mode-line
  "Minor mode to hide the mode-line in the current buffer."
  :init-value nil
  :global t
  :variable toggle-mode-line
  :group 'editing-basics
  (if toggle-mode-line
      (setq hide-mode-line mode-line-format
            mode-line-format nil)
    (setq mode-line-format hide-mode-line
          hide-mode-line nil))
  (force-mode-line-update)
  (redraw-display)
  (when (and (called-interactively-p 'interactive)
             toggle-mode-line)
    (run-with-idle-timer
     0 nil 'message
     (concat "Hidden mode line mode enabled.  "
             "Use M-x toggle-mode-line to make the mode-line appear."))))
;; If you want to hide the mode-line in every buffer by default
;; (add-hook 'after-change-major-mode-hook 'toggle-mode-line)
#+END_SRC



** Key Bindings
**** hydra keys
#+BEGIN_SRC emacs-lisp
(use-package hydra
  :ensure t
  :init
  (defhydra hydra-zoom (global-map "<f2>")
    "zoom"
    ("g" text-scale-increase "in")
    ("l" text-scale-decrease "out")))

#+END_SRC



** Alias


** Platform Dependent Setup
